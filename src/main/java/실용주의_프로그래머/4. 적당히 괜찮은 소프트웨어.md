> 우리는 종종 뭔가 나아지게 하려다가 괜찮은 것마저 망친다 (리어왕 1.4)

- 일본 제조사에 집적회로 10만 개를 주문하는 미국 회사에 관한 오래된 농담이 있다
- 명세의 일부로 결함 비율이 포함됐고 만 개당 칩 하나였다. 몇 주 후에 제품이 도착했다. 10만 개의 IC가 들어있는 큰 상자 하나와 IC 10개만 들어있는
작은 상자 하나였다. 작은 상자에는 "이것은 결함이 있는 것들입니다" 라고 라벨이 붙어 있었다
- 이런 정도로까지 품질을 통제할 수 있다면 좋겠지만 실세계에선 진정 완벽한 것을 만들어내기란 불가능하다. 특히 버그 없는 소프트웨어는 더더욱. 시간, 기술,
기질 같은 것들이 모두 공모해서 우리를 방해한다
- 그렇지만 그게 우리를 꼭 낙담케 하지만은 않는다. 에드워드 요든이 IEEE 소프트웨어의 기사에서 설명한 바와 같이 적당히 괜찮은(사용자, 미래의 유지보수자
혹은 자기 마음의 평화를 유지하기에 적당히 괜찮은) 소프트웨어를 만들도록 자신을 단련할 수 있다
- 자신은 더 생산적이 되고 사용자는 한층 행복해 할 것이다. 그리고 내 프로그램이 사실은 짧은 인큐베이션 기간에 비해 낫다는 걸 알게 될 것이다
- 더 나아가기 앞서 명확히 해둘 것이 있다. '적당히 괜찮은'이라는 문구는 너절하거나 형편없는 코드를 의미하지 않는다
- 시스템이 성공하려면 사용자 요구사항을 충족해야 한다. 단지 우리는 내가 생산한 것이 어느 정도면 적당히 괜찮은지를 결정하는 과정에 사용자가 참가할 기회를
가져야 한다는 걸 말하고 있는 것이다

## 타협과정에 사용자를 참여시켜라

- 여러분은 보통 타인을 위해 소프트웨어를 작성한다. 하지만 소프트웨어가 `얼마나 좋아야 하는지` 사용자들에게 얼마나 자주 묻는가?
- 때로는 선택이 불가능한 경우도 있다. 맥박 조종기, 우주선, 널리 유포될 저차원 라이브러리 같은 걸 만든다면 요구사항은 훨씬 엄격하고 운신의 폭은 제한될 것이다
- 그렇지만 전혀 새로운 상품을 만들고 있다면 좀 다른 제약조건이 있기 마련이다. 마케팅하는 사람들이 지켜야 할 약속이 있을 수 있고, 최종 사용자가 납품 일정에 따라
계획을 세웠을 수 있고, 회사에 현금 유동 제약이 분명 있을 수 있을 것이다. 단순히 프로그램에 새 기능을 추가하거나 코드를 한 번 더 다듬는다던가 하기 위해서
사용자의 요구사항을 무시하는 건 전문가답지 못한 것이다. 우리는 허둥대라고 주창하는 게 아니다. 불가능한 시간 약속을 하거나 데드라인에 맞추기 위해 기본적인 걸
빼버리거나 하는 것 역시 똑같이 전문가답지 못하다
- 내가 만드는 시스템의 범위(scope)와 품질은 해당 시스템 요구사항의 일부로 명기돼야 한다

> 실용주의 프로그래머 Tip 7  
> 품질을 요구사항으로 만들어라

- 우리는 적당한 타협이 필요한 상황에 자주 처하게 된다. 놀랍게도 많은 사용자들은 멀티미디어 버전을 위해 1년을 기다리느니 차라리 오늘 당장 좀 불편한 소프트웨어를
사용하고 싶어 한다
- 오늘의 훌륭한 소프트웨어는 많은 경우, 내일의 완벽한 소프트웨어보다 낫다. 사용자들에게 뭔가 직접 만져볼 수 있는 것을 일찍 준다면 피드백을 통해 종국에는 더
나은 솔루션에 도달할 수 있을 것이다(96쪽 예광탄 참조)

## 언제 멈춰야 할지 알라

- 어떤 면에서 프로그래밍은 그림 그리기와 유사하다. 깨끗한 캔버스와 몇 가지 기본 재료를 갖고 시작한다. 과학, 예술, 기술을 조합해서 그것들로 뭘 할지 결정한다
- 전체 그림을 스케치하고 주변 환경을 칠한 다음, 세부 내용을 채워 넣는다. 자신이 한 것을 비판적인 눈으로 보기 위해 늘 뒤로 물러서서 보기도 한다. 때로는 캔버스를
버리고 완전히 새로 시작하기도 한다
- 하지만 예술가들은 여러분에게 언제 멈춰야 할지를 알지 못하면 이 모든 고된 작업을 망치게 될 거라고 말해준다. 칠한 위에 덧칠하고, 세부묘사 위에 다시 세부묘사를
하다보면 `그림은 물감 속에서 사라진다`
- 완벽하게 훌륭한 프로그램을 과도하게 장식하거나 지나칠 정도로 다듬느라 망치지 마라. 그냥 넘어가고 코드가 현 상태에서 한동안은 그대로 있도록 놔둬라. 완벽하지 않을
수도 있다. 걱정 마라. 완벽해지기란 불가능하다 (6장 271p에서 불완전한 세계에서 코드를 개발하기 위한 철학을 논의할 것이다)